//Class libraries are used to contain the things talked about in “The Role of .NET Core Assemblies” section.
//Class libraries are compiled into DLL files, which are .NET assemblies. An assembly is a compiled code library used for deployment, versioning, and security.
//Assemblies contain metadata about the types and resources they contain, which allows the .NET runtime to manage them effectively.
//Class libraries can be referenced by other projects, allowing code reuse and modular development.
//Class libraries can be created using various .NET languages, including C#, VB.NET, and F#.
//Class libraries can be created using different project templates, such as Class Library (.NET Core),
//Class Library (.NET Standard), or Class Library (.NET Framework).
//Class libraries can be distributed as NuGet packages, which are a convenient way to share and reuse code across
//different projects and teams.This enables code sharing across multiple applications and services.
//Class libraries can be used to encapsulate business logic such as authentication, validation, calculation,
//data access in utility or helper functions (logging, file I/O, DB Access), and other reusable components.
//Class libraries can be versioned independently of the applications that use them, allowing for easier maintenance and updates.
//Class libraries can be tested independently of the applications that use them, allowing for better quality assurance and debugging.
//Class libraries can be documented using XML comments, which can be extracted to generate API documentation.
//Class libraries can be created and managed using various tools, such as Visual Studio, .NET CLI, and JetBrains Rider.
//Class libraries can be created to target different .NET runtimes, such as .NET Core, .NET Framework, or Xamarin.
//Class libraries can be created to target different platforms, such as Windows, Linux, macOS, iOS, and Android.
//Class libraries can be created to target different architectures, such as x86, x64, ARM, and ARM64.
//Class libraries can be created to target different versions of the .NET runtime, allowing for compatibility with older or newer applications.
//Class libraries can be created to use different programming paradigms, such as object-oriented programming, functional programming, and procedural programming.
//Class libraries can be created to use different design patterns, such as Singleton, Factory, and Repository.
//Class libraries can be created to use different frameworks and libraries, such as ASP.NET Core, Entity Framework Core, and Newtonsoft.Json.
//Class libraries can be created to use different testing frameworks, such as xUnit, NUnit, and MSTest.
//Class libraries can be created to use different build systems, such as MSBuild, Cake, and FAKE.
//Class libraries can be created to use different version control systems, such as Git, SVN, and Mercurial.
//Class libraries can be created to use different continuous integration and continuous deployment (CI/CD) tools, such as Azure DevOps, GitHub Actions, and Jenkins.
//Class libraries can be created to use different package managers, such as NuGet, npm, and Yarn.
//Class libraries can be created to use different code analysis tools, such as SonarQube, ReSharper, and CodeRush.
// class libraries don’t have an entry point and therefore cannot be launched directly
//Class libraries can be created to use different logging frameworks, such as Serilog, NLog, and log4net.
//Class libraries can be created to use different dependency injection frameworks, such as Microsoft.Extensions.DependencyInjection, Autofac, and Ninject.
//Class libraries can be created to use different serialization frameworks, such as System.Text.Json, Newtonsoft.Json, and Protobuf.NET.
//They are used to encapsulate logic, custom types, and so on, and they are referenced by other class libraries and / or console applications.
